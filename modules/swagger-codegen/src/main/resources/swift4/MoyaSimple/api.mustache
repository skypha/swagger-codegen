{{#operations}}//
// {{classname}}.swift
//
// Generated by swagger-codegen
// https://github.com/swagger-api/swagger-codegen
//

import Foundation
import Moya

{{#description}}
/** {{description}} */{{/description}}

open enum {{classname}}Service {
{{#operation}}
    case {{operationId}}({{#allParams}}{{paramName}}: {{#isEnum}}{{#isContainer}}{{{dataType}}}{{/isContainer}}{{^isContainer}}{{{datatypeWithEnum}}}_{{operationId}}{{/isContainer}}{{/isEnum}}{{^isEnum}}{{{dataType}}}{{/isEnum}}{{^required}}? = nil{{/required}}{{#hasMore}}, {{/hasMore}}{{/allParams}})
{{/operation}}
}

{{#allParams}}
{{#isEnum}}
/**
* enum for parameter {{paramName}}
*/
public enum {{enumName}}_{{operationId}}: {{^isContainer}}{{{dataType}}}{{/isContainer}}{{#isContainer}}String{{/isContainer}} { {{#allowableValues}}{{#enumVars}}
    case {{name}} = {{#isContainer}}"{{/isContainer}}{{#isString}}"{{/isString}}{{{value}}}{{#isString}}"{{/isString}}{{#isContainer}}"{{/isContainer}}{{/enumVars}}{{/allowableValues}}
}

{{/isEnum}}
{{/allParams}}

// MARK: - TargetType Protocol Implementation
extension {{classname}}Service: TargetType {
    // the url of your API, it should include also the version if u use a version
    var baseURL: URL { return URL(string: NetworkService.baseURL)! }

    /** path
     * defines the real path corresponding to each case
     * if multiple cases match the same path, you just concat the cases
     * Example
     *  case .getUser(let id), .updateUser(let id, _, _): return "/users/\(id)"
     */
    var path: String {
        switch self {
        {{#operation}}
            case .{{operationId}}({{#allParams}}{{#isPathParam}}let {{paramName}}{{/isPathParam}}{{^isPathParam}} _{{/isPathParam}}{{#hasMore}}, {{/hasMore}}{{/allParams}}):
                return "{{{path}}}"
        {{/operation}}
        }
    }

     /** Method
     * defined the REST-Type
     * normally you will use: .get, .post, .delete
     * For more information see https://tools.ietf.org/html/rfc7231#section-4.3
     */
    var method: Moya.Method {
        switch self {
        {{#operation}}
        case .{{operationId}}:
            return {{httpMethod}}
        {{/operation}}
        }
    }

    /** Task
     * Defines the request parameters for each request
     * U can use different types of Tasks, to fit the REST-API definition
     */
    var task: Task {
        switch self {
        {{#operation}}
        case .{{operationId}}({{#allParams}}{{#isPathParam}}_{{/isPathParam}}{{^isPathParam}}let {{paramName}}{{/isPathParam}}{{#hasMore}}, {{/hasMore}}{{/allParams}}):
            {{#hasBodyParam}}{{^hasQueryParams}}{{#bodyParams}}{{^hasMore}}return .requestJSONEncodable({{#bodyParams}}{{paramName}}{{/bodyParams}}){{/hasMore}}{{#hasMore}}return .requestParameters(){{/hasMore}}{{/bodyParams}}{{/hasQueryParams}}{{/hasBodyParam}}{{^hasBodyParam}}return .requestPlain{{/hasBodyParam}}
        {{/operation}}
        }

    /**
     * Sample data is used for stubbing
     * If stubbing for one of your cases is used (backend not implemented or testing without network requests), you need to provide the data here.
     */
    var sampleData: Data {
        switch self {
        {{#operation}}
        case .{{operationId}}:
            // Provided you have a file named accounts.json in your bundle.
            guard let url = Bundle.main.url(forResource: "{{operationId}}Mock", withExtension: "json"),
                let data = try? Data(contentsOf: url) else {
                    return Data()
            }
            return data
        }
        {{/operation}}
    }
    
{{/operations}}
